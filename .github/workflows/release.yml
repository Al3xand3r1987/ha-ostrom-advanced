name: Release

on:
  release:
    types: [published]  # Triggert bei manuell erstellten Releases auf GitHub
  push:
    tags:
      - 'v*'  # Triggert auch bei Tag-Push (z.B. v0.4.0)
  workflow_dispatch:  # Erm√∂glicht manuelles Triggern √ºber GitHub UI
    inputs:
      tag_name:
        description: 'Tag name (z.B. v0.4.0)'
        required: true
        type: string

permissions:
  contents: write  # Erforderlich f√ºr das Aktualisieren von Releases
  issues: read    # F√ºr Release-Drafter (falls verwendet)

jobs:
  update-release-notes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Vollst√§ndige Git-Historie f√ºr Release Notes

      - name: Setup GitHub CLI
        run: |
          # Pr√ºfe ob GitHub CLI bereits installiert ist
          if command -v gh &> /dev/null; then
            echo "‚úÖ GitHub CLI already installed: $(gh --version | head -n 1)"
          else
            echo "üì¶ Installing GitHub CLI..."
            type -p curl >/dev/null || (apt update && apt install curl -y)
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
            && chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
            && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
            && apt update \
            && apt install gh -y
            echo "‚úÖ GitHub CLI installed successfully"
          fi

      - name: Get current tag
        id: current_tag
        run: |
          # Pr√ºfe ob es ein Release-Event oder Tag-Push-Event ist
          if [ -n "${{ github.event.release.tag_name }}" ]; then
            CURRENT_TAG="${{ github.event.release.tag_name }}"
          elif [ -n "${{ github.event.inputs.tag_name }}" ]; then
            # Bei workflow_dispatch: Tag-Name aus Input nehmen
            CURRENT_TAG="${{ github.event.inputs.tag_name }}"
          else
            # Bei Tag-Push: Tag-Name aus Ref extrahieren
            CURRENT_TAG="${GITHUB_REF#refs/tags/}"
          fi
          echo "Current tag: $CURRENT_TAG"
          echo "tag_name=$CURRENT_TAG" >> $GITHUB_OUTPUT

      - name: Get previous tag
        id: previous_tag
        run: |
          CURRENT_TAG="${{ steps.current_tag.outputs.tag_name }}"
          echo "Current release tag: $CURRENT_TAG"
          
          # Versuche vorherigen Tag zu finden
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 ${CURRENT_TAG}^ 2>/dev/null || echo "")

          if [ -z "$PREVIOUS_TAG" ]; then
            # Fallback: Suche nach dem letzten Tag vor dem aktuellen
            PREVIOUS_TAG=$(git tag --sort=-v:refname | grep -v "^${CURRENT_TAG}$" | head -n 1 || echo "")
          fi

          if [ -z "$PREVIOUS_TAG" ]; then
            # Letzter Fallback: Erster Commit
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD 2>/dev/null || echo "")
            if [ -z "$PREVIOUS_TAG" ]; then
              echo "‚ö†Ô∏è No previous tag or commit found, using empty range"
              PREVIOUS_TAG="${CURRENT_TAG}^"
            else
              echo "‚ö†Ô∏è No previous tag found, using first commit: $PREVIOUS_TAG"
            fi
          else
            echo "‚úÖ Found previous tag: $PREVIOUS_TAG"
          fi
          
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          echo "Generating release notes from $PREVIOUS_TAG to $CURRENT_TAG"

      - name: Generate release notes from commits
        id: release_notes
        run: |
          CURRENT_TAG="${{ steps.current_tag.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          
          echo "üìù Generating release notes from $PREVIOUS_TAG to $CURRENT_TAG"
          
          # Pr√ºfe ob es Commits gibt
          COMMIT_COUNT=$(git rev-list --count ${PREVIOUS_TAG}..${CURRENT_TAG} 2>/dev/null || echo "0")
          echo "Found $COMMIT_COUNT commits between $PREVIOUS_TAG and $CURRENT_TAG"
          
          if [ "$COMMIT_COUNT" -eq "0" ] || [ -z "$COMMIT_COUNT" ]; then
            echo "‚ö†Ô∏è No commits found between tags, creating empty release notes"
            echo 'notes<<EOF' > $GITHUB_OUTPUT
            echo "## üì¶ Release $CURRENT_TAG" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "No commits found between $PREVIOUS_TAG and $CURRENT_TAG" >> $GITHUB_OUTPUT
            echo EOF >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Kategorisiere Commits nach Conventional Commits
          # Priorit√§t: Features ‚Üí Fixes ‚Üí Maintenance ‚Üí Docs
          # Verwende --no-merges um Merge-Commits auszuschlie√üen
          FEATURES=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*(feat|feature):" | sed 's/^-\s*\(feat\|feature\):/-/' || echo "")
          FIXES=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*(fix|bug):" | sed 's/^-\s*\(fix\|bug\):/-/' || echo "")
          CHORES=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*(chore|refactor):" | sed 's/^-\s*\(chore\|refactor\):/-/' || echo "")
          DOCS=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*docs:" | sed 's/^-\s*docs:/-/' || echo "")
          OTHER=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -vE "^-\s*(feat|feature|fix|bug|docs|chore|refactor):" || echo "")
          
          echo "üìä Categorized commits:"
          echo "  Features: $(echo "$FEATURES" | grep -c "^" || echo "0")"
          echo "  Fixes: $(echo "$FIXES" | grep -c "^" || echo "0")"
          echo "  Chores: $(echo "$CHORES" | grep -c "^" || echo "0")"
          echo "  Docs: $(echo "$DOCS" | grep -c "^" || echo "0")"
          echo "  Other: $(echo "$OTHER" | grep -c "^" || echo "0")"
          
          # Baue Release Notes zusammen (Priorit√§t: Features ‚Üí Fixes ‚Üí Maintenance ‚Üí Docs)
          {
            echo 'notes<<EOF'
            if [ -n "$FEATURES" ]; then
              echo "## üöÄ New Features"
              echo "$FEATURES"
              echo ""
            fi
            if [ -n "$FIXES" ]; then
              echo "## üêõ Bug Fixes"
              echo "$FIXES"
              echo ""
            fi
            if [ -n "$CHORES" ]; then
              echo "## üîß Maintenance"
              echo "$CHORES"
              echo ""
            fi
            if [ -n "$DOCS" ]; then
              echo "## üìù Documentation"
              echo "$DOCS"
              echo ""
            fi
            if [ -n "$OTHER" ]; then
              echo "## üì¶ Other Changes"
              echo "$OTHER"
            fi
            echo EOF
          } >> $GITHUB_OUTPUT

      - name: Get existing release body
        id: existing_body
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Pr√ºfe ob Release bereits existiert (bei Tag-Push)
          CURRENT_TAG="${{ steps.current_tag.outputs.tag_name }}"
          if [ -n "${{ github.event.release.body }}" ] && [ "${{ github.event.release.body }}" != "null" ]; then
            EXISTING_BODY="${{ github.event.release.body }}"
            echo "has_existing_body=true" >> $GITHUB_OUTPUT
            echo "Existing release notes found, keeping them"
          else
            # Pr√ºfe ob Release bereits auf GitHub existiert
            gh auth setup-git
            RELEASE_EXISTS=$(gh release view "$CURRENT_TAG" --json body 2>/dev/null || echo "")
            if [ -n "$RELEASE_EXISTS" ]; then
              RELEASE_BODY=$(echo "$RELEASE_EXISTS" | jq -r '.body // ""')
              if [ -n "$RELEASE_BODY" ] && [ "$RELEASE_BODY" != "null" ] && [ "$RELEASE_BODY" != "" ]; then
                echo "has_existing_body=true" >> $GITHUB_OUTPUT
                echo "Existing release found on GitHub, keeping existing notes"
              else
                echo "has_existing_body=false" >> $GITHUB_OUTPUT
                echo "Release exists but has no notes, will generate new ones"
              fi
            else
              echo "has_existing_body=false" >> $GITHUB_OUTPUT
              echo "No existing release found, will create new release with generated notes"
            fi
          fi

      - name: Create or Update Release (only if no existing notes)
        if: steps.existing_body.outputs.has_existing_body == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.current_tag.outputs.tag_name }}
          name: Ostrom Advanced ${{ steps.current_tag.outputs.tag_name }}
          body: |
            ${{ steps.release_notes.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Notes already exist
        if: steps.existing_body.outputs.has_existing_body == 'true'
        run: |
          echo "Release notes were manually added, keeping them unchanged"
          echo "Generated notes are available in the workflow logs for reference"

      - name: Update RELEASE_NOTES.md file
        run: |
          CURRENT_TAG="${{ steps.current_tag.outputs.tag_name }}"
          PREVIOUS_TAG="${{ steps.previous_tag.outputs.previous_tag }}"
          VERSION="${CURRENT_TAG#v}"  # Entferne 'v' Pr√§fix
          
          echo "üìù Updating RELEASE_NOTES.md for version $VERSION"
          
          # Sammle Commits erneut (Variablen aus vorherigem Step sind nicht verf√ºgbar)
          # Verwende --no-merges um Merge-Commits auszuschlie√üen
          FEATURES=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*(feat|feature):" | sed 's/^-\s*\(feat\|feature\):/-/' || echo "")
          FIXES=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*(fix|bug):" | sed 's/^-\s*\(fix\|bug\):/-/' || echo "")
          CHORES=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*(chore|refactor):" | sed 's/^-\s*\(chore\|refactor\):/-/' || echo "")
          DOCS=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -E "^-\s*docs:" | sed 's/^-\s*docs:/-/' || echo "")
          OTHER=$(git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges 2>/dev/null | grep -vE "^-\s*(feat|feature|fix|bug|docs|chore|refactor):" || echo "")
          
          # Erstelle neuen Release Notes Eintrag
          {
            echo "# Ostrom Advanced v$VERSION"
            echo ""
            if [ -n "$FEATURES" ]; then
              echo "## New Features"
              echo "$FEATURES"
              echo ""
            fi
            if [ -n "$FIXES" ]; then
              echo "## Bug Fixes"
              echo "$FIXES"
              echo ""
            else
              echo "## Bug Fixes"
              echo "- Keine Bug-Fixes"
              echo ""
            fi
            if [ -n "$CHORES" ]; then
              echo "## Maintenance"
              echo "$CHORES"
              echo ""
            else
              echo "## Maintenance"
              echo "- Keine Wartungsarbeiten"
              echo ""
            fi
            if [ -n "$DOCS" ]; then
              echo "## Documentation"
              echo "$DOCS"
              echo ""
            fi
            if [ -n "$OTHER" ]; then
              echo "## Other Changes"
              echo "$OTHER"
              echo ""
            else
              echo "## Other Changes"
              echo "- Keine weiteren √Ñnderungen"
              echo ""
            fi
            echo "---"
            echo ""
          } > /tmp/new_release_notes.txt
          
          # F√ºge neuen Eintrag am Anfang der Datei ein
          if [ -f RELEASE_NOTES.md ]; then
            cat /tmp/new_release_notes.txt RELEASE_NOTES.md > /tmp/updated_release_notes.md
            mv /tmp/updated_release_notes.md RELEASE_NOTES.md
          else
            mv /tmp/new_release_notes.txt RELEASE_NOTES.md
          fi
          
          echo "‚úÖ RELEASE_NOTES.md updated"

      - name: Commit and push RELEASE_NOTES.md
        run: |
          CURRENT_TAG="${{ steps.current_tag.outputs.tag_name }}"
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          
          # Pr√ºfe ob wir auf main sind
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "‚ö†Ô∏è Not on main branch ($CURRENT_BRANCH), skipping RELEASE_NOTES.md commit"
            echo "RELEASE_NOTES.md will only be committed when workflow runs on main branch"
            exit 0
          fi
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add RELEASE_NOTES.md
          if ! git diff --staged --quiet; then
            git commit -m "docs: update RELEASE_NOTES.md for $CURRENT_TAG"
            git push
            echo "‚úÖ RELEASE_NOTES.md committed and pushed to main"
          else
            echo "‚ÑπÔ∏è No changes to RELEASE_NOTES.md"
          fi